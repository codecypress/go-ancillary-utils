package querymanager

/*//ADAPTED FROM: github.com/knetic/go-namedparameterquery

import (
	"ke/co/skyworld/ancillary-utils/utils/beans/cypressHashMap"
	"bytes"
	"errors"
	"fmt"
	"reflect"
	"unicode"
	"unicode/utf8"
)

type NamedParameterQuery struct {

	// A map of parameter names as keys, with value as a slice of positional indices which match
	// that parameter.
	positions map[string][]int

	// Contains all positional parameters, in order, ready to be used in the positional query.
	parameters []interface{}

	// The query containing named parameters, as passed in by NewNamedParameterQuery
	originalQuery string

	// The query containing positional parameters, as generated by setQuery
	revisedQuery string
}

func NewNamedParameterQuery(queryText string) *NamedParameterQuery {

	var ret *NamedParameterQuery

	// TODO: I don't like using a map for such a small amount of elements.
	// If this becomes a bottleneck for anyone, the first thing to do would
	// be to make a slice and search routine for parameter positions.
	ret = new(NamedParameterQuery)
	ret.positions = make(map[string][]int, 8)
	ret.setQuery(queryText)

	return ret
}

func (this *NamedParameterQuery) setQuery(queryText string) {

	var revisedBuilder bytes.Buffer
	var parameterBuilder bytes.Buffer
	var position []int
	var character rune
	var parameterName string
	var width int
	var positionIndex int

	this.originalQuery = queryText
	positionIndex = 0

	for i := 0; i < len(queryText); {

		character, width = utf8.DecodeRuneInString(queryText[i:])
		i += width

		// if it's a colon, do not write to builder, but grab name
		if(character == ':') {

			for ;; {

				character, width = utf8.DecodeRuneInString(queryText[i:])
				i += width

				if unicode.IsLetter(character) || unicode.IsDigit(character) {
					parameterBuilder.WriteString(string(character))
				} else {
					break
				}
			}

			// add to positions
			parameterName = parameterBuilder.String()
			position = this.positions[parameterName]
			this.positions[parameterName] = append(position, positionIndex)
			positionIndex++

			revisedBuilder.WriteString("?")
			parameterBuilder.Reset()

			if(width <= 0) {
				break
			}
		}

		// otherwise write.
		revisedBuilder.WriteString(string(character))

		// if it's a quote, continue writing to builder, but do not search for parameters.
		if(character == '\'') {

			for ;; {

				character, width = utf8.DecodeRuneInString(queryText[i:])
				i += width
				revisedBuilder.WriteString(string(character))

				if(character == '\'') {
					break
				}
			}
		}
	}

	this.revisedQuery = revisedBuilder.String()
	this.parameters = make([]interface{}, positionIndex)
}

func (this *NamedParameterQuery) GetParsedQuery() (string) {
	return this.revisedQuery
}

func (this *NamedParameterQuery) GetParsedParameters() ([]interface{}) {
	return this.parameters
}

func (this *NamedParameterQuery) SetValue(parameterName string, parameterValue interface{}) {

	for _, position := range this.positions[parameterName] {
		this.parameters[position] = parameterValue
	}
}

func (this *NamedParameterQuery) SetValuesFromMap(parameters map[string]interface{}) {

	for name, value := range parameters {
		this.SetValue(name, value)
	}
}

func (this *NamedParameterQuery) SetValuesFromCypressCoreHashMap(parameters *cypressHashMap.CypressHashMap) {
	for pair := parameters.GetData().Oldest(); pair != nil; pair = pair.Next() {
		column := fmt.Sprintf("%v", pair.Key)
		this.SetValue(column, pair.Value)
	}
}

func (this *NamedParameterQuery) SetValuesFromStruct(parameters interface{}) (error) {

	var fieldValues reflect.Value
	var fieldValue reflect.Value
	var parameterType reflect.Type
	var parameterField reflect.StructField
	var queryTag string
	var visibilityCharacter rune

	fieldValues = reflect.ValueOf(parameters)

	if(fieldValues.Kind() != reflect.Struct) {
		return errors.New("Unable to add query values from parameter: parameter is not a struct")
	}

	parameterType = fieldValues.Type()

	for i := 0; i < fieldValues.NumField(); i++ {

		fieldValue = fieldValues.Field(i)
		parameterField = parameterType.Field(i)

		// public field?
		visibilityCharacter, _ = utf8.DecodeRuneInString(parameterField.Name[0:])

		if(fieldValue.CanSet() || unicode.IsUpper(visibilityCharacter)) {

			// check to see if this has a tag indicating a different query name
			queryTag = parameterField.Tag.Get("sqlParameterName")

			// otherwise just add the struct's name.
			if(len(queryTag) <= 0) {
				queryTag = parameterField.Name
			}

			this.SetValue(queryTag, fieldValue.Interface())
		}
	}
	return nil
}
*/
